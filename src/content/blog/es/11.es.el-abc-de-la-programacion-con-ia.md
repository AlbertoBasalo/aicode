---
title: "El ABC de la Programaci√≥n con IA"
subtitle: "Metodolog√≠a de programaci√≥n con agentes IA, Architect, Builder, Craftsman"
description: "Desarrollar soluciones es m√°s que programar. Requiere saber qu√© hacer y mantener lo hecho. Los roles b√°sicos son: Architect, Builder, Craftsman tambi√©n pueden ser agentes o asistentes de IA"
date: "2025-01-15"
category: "procedimientos"
slug: "el-abc-de-la-programacion-con-ia"
---

Desarrollar soluciones de software es **mucho m√°s que programar**. Requiere saber qu√© hacer y por supuesto mantener lo hecho. Es un trabajo intelectual al que le toca el turno de ser automatizado.

LA IA puede manifestarse en diferentes formas: como un simple chat, un asistente, o un agente aut√≥nomo. Pero siempre es algo **m√°s que una herramienta**. Me resulta √∫til verlo como un miembro m√°s del equipo, pero con distintas perspectivas.


## El ciclo del desarrollo

La ingenier√≠a de software ha evolucionado mucho desde hace m√°s d√©cadas de las que me cuesta aceptar recordar. Pero, en general, he comprobado que una serie de **tareas y metodolog√≠as** se han mantenido comunes a todos los desarrollos.	

### Tareas

Sabemos que desarrollar software es un **proceso complejo** que requiere una serie de pasos. De los cuales, uno de ellos es codificar. Por ah√≠ hemos empezado todos. Y por ah√≠ hemos empezado con la IA; auto-completado de c√≥digo m√°s o menos inteligente.

Pero m√°s all√° de codificar est√°n otras tareas tan importantes como la planificaci√≥n, an√°lisis, dise√±o, pruebas y mantenimiento. Y todas ellas, como trabajos _white-collar_, son susceptibles de ser automatizadas, impulsadas o mejoradas con IA.

### Metodolog√≠as

No todos los proyectos son iguales. Dependen de las necesidades (m√°s o menos complejas) y de las personas (m√°s o menos expertas) que los desarrollan. Las diferentes metodolog√≠as de desarrollo se adaptan mejor a unos que a otros.

Seguramente conozcas algunas de ellas: `waterfall`, `agile`, `lean`, `big-bang`, etc. Pero, ¬øqu√© es lo que tienen en com√∫n?

Todas ellas envuelven de alguna la manera al proceso de programaci√≥n, definiendo qu√© hacer y verificando que sea mantenible.

#### Herramientas, procesos, personas y roles

Para llevar a cabo el desarrollo de software (en realidad de cualquier otro proyecto complejo), necesitamos herramientas, procesos, y personas que cumplan roles.

La llegada de la IA, nos plantea la duda de qu√© es. ¬øEs una herramienta, o es algo o _alguien_ m√°s?

#### La analog√≠a de la edificaci√≥n

Una analog√≠a muy manida en el mundo del software es su comparaci√≥n con la edificaci√≥n. El arquitecto dise√±a el edificio, el constructor con su equipo de alba√±iles lo construye, y los manitas de turno lo mantienen. No es uno para uno, pero claramente identifica los roles que dan respuesta a las preguntas de cualquier proyecto: **¬øqu√© hacer?, ¬øc√≥mo hacerlo?, ¬øc√≥mo mantenerlo?**.

En una obra, uno puede olvidarse o desconocer algo, pero nunca confundir un martillo con un electricista.

Para m√≠, la IA es m√°s que una herramienta. Es al menos un asistente, y puede ser un agente aut√≥nomo. **Uno m√°s en el equipo.** Y por tanto le asigno un rol.

En un esfuerzo por abordarlo de la forma m√°s simple posible, he identificado los tres roles que, en mi opini√≥n, son **el ABC de la programaci√≥n**, y por extensi√≥n, del desarrollo con IA. Adem√°s, en la lengua del imperio, me encaja con el acr√≥nimo simpl√≥n pero result√≥n ABC: `Architect`, `Builder`, `Craftsman`. Veamos qu√© es cada uno.

## üßë‚Äçüî¨ Architect

Bajo este paraguas meto todas aquellas tareas que definen el proyecto. Desde su objetivo, funcionalidad esperada, hasta la arquitectura de la soluci√≥n. En concreto esto me lleva a dos tareas principales para el asistente: **planificaci√≥n y an√°lisis**.

> üìê Para este rol, escojo como herramienta principal un modelo de lenguaje. Cuanto m√°s avanzado, mejor. As√≠ que si te lo puedes permitir, elige un modelo con capacidades de razonamiento o pensamiento profundo. `ChatGPT`, `Claude` y `Gemini` son los que mejor se adaptan a este rol.

### Planificaci√≥n

El asistente debe ayudarme a definir el proyecto. Mediante una serie de preguntas, debe entender el problema y las expectativas. Y generar un documento que sirva como _briefing_ para empezar a trabajar.

En proyectos muy simples, pruebas de concepto o MVP, esto puede ser suficiente para un sar como prompt de one-shot Builders como `Lovable`, `v0` o `Bolt`. 

Pero en proyectos reales, hace falta m√°s. Al menos, una lista detallada de las funcionalidades como _user-stories_ y alg√∫n _diagrama mermaid_ de alto nivel.

### An√°lisis

En esta tarea, el asistente debe aplicar toda su _inteligencia_, si es que la tiene... Porque aqu√≠ es donde m√°s la necesitamos para **pasar del problema a la soluci√≥n.**

Los modelos m√°s avanzados ofrecen capacidades de razonamiento, o pensamiento profundo que no pueden proponer una arquitectura del sistema y las tecnolog√≠as que lo soportan.

Tambi√©n puede detallar las funcionalidades al nivel de _use-cases_ que sirvan tanto para implementar como para probar la soluci√≥n.

Cualquier diagrama de flujo, contexto o arquitectura que ayude a entender el problema y la soluci√≥n es bienvenido.

## üë∑ Builder

La construcci√≥n de la soluci√≥n es la raz√≥n de ser de la ingenier√≠a de software. Independiente de m√©todolog√≠as m√°s lineales o c√≠clicas, estos suelen ser los procesos centrales y que m√°s recursos y tiempo requieren. La IA, tambi√©n les presta la debida atenci√≥n.

> üèóÔ∏è En esta fase se difuminan las barreras entre herramientas. En principio ser√≠a un caso de uso para editores inteligentes como `Cursor`, `Windsurf`, `aider`, etc. Pero en realidad, un buen `LLM` puede ayudarte, especialmente en la fase de dise√±o, previa a la implementaci√≥n. Ojo, que los agentes online tipo `Bolt` o `Lovable` son excelentes para crear el _scaffold_ de un proyecto, aunque se quedan cortos para implementar funcionalidades. Tambi√©n puedes usar `Copilot`, `Continue` o cualquier extensi√≥n que complete el c√≥digo, pero no son agentes.

### Dise√±o

Cualquier proyecto no trivial requiere un dise√±o. Especificaciones de **usabilidad, modelos de datos, est√°ndares** de codificaci√≥n, etc. Todos son documentos que pueden ser generados por el asistente y adjuntados al proyecto.

Puedes ir m√°s all√° e incluso pedirle que genere las funcionalidades al nivel de _use-cases_ como `pseudo-c√≥digo`. Cualquier paso intermedio es una oportunidad de revisi√≥n humana para corregir o refinar el proyecto.

### Implementaci√≥n

Aqu√≠ empez√≥ todo. Hace ya unos a√±os que me qued√© perplejo viendo como `GitHub Copilot` me le√≠a la mente y completaba c√≥digo ante mis ojos. A d√≠a de hoy eso me parece una proceso superficial y me averg√ºenzo de mi pasado _naif_ tratando a `Copilot` como un ente pensante.

Con todo lo generado por el Arquitecto y la fase de dise√±o usada como contexto, los actuales generadores de c√≥digo como  `Cursor`/`Composer` pueden crear carpetas, ficheros y hasta proyectos enteros. Lo dicho, _un completador de c√≥digo no es un agente_ y se queda corto para considerarse un Builder.

Como el tama√±o importa, el Builder har√° un mejor trabajo si le pides funcionalidades concretas y peque√±as. Y a√∫n mejor, si le pides que te genere **un plan previo, antes de que escriba el c√≥digo definitivo**. S√≠ lo s√©, es una tarea m√°s con su coste de recursos y tiempo, pero, cr√©eme que mejora mucho la calidad resultante y reduce las alucinaciones que a√∫n hoy en d√≠a se dan en los modelos estoc√°sticos.

Antes de pasar al nivel de artesan√≠a, recordarte que el Builder, debe **escribir buen c√≥digo** (te guste limpio, funcional o procedimental) **con sus pruebas y su documentaci√≥n** (por m√°s que despu√©s lo podamos mejorar).

## üßë‚Äçüè≠ Craftsman

El _software_ se llama as√≠ para denotar su naturaleza evolutiva y distinguirlo del _hardware inmutable_. Todo lo que se desarrolla es susceptible de ser mejorado, modificado, extendido, etc. En definitiva hay que mantenerlo. Y adem√°s hacerlo con el cuidado y atenci√≥n a los detalles que har√≠a un artesano.

> ü™õ Para este rol, ya no aplica tanto el LLM en solitario. Es un trabajo muy de refinado inmediato. Los agentes de los editores inteligentes como `Cursor`, `Windsurf`, `aider`, etc. son excelentes para este caso. Eso s√≠, aseg√∫rate de usar un modelo de servicio que admita la mayor cantidad de contexto posible.

### Pruebas

Como vimos, durante la fase de implementaci√≥n se puede, y deben, exigir pruebas unitarias como parte de la generaci√≥n de c√≥digo. Pero, como tambi√©n te dije, cuanto m√°s abarques menos apretar√°s, y suele ser necesario completar la **verificaci√≥n del sistema** con pruebas de usabilidad, e2e o de integraci√≥n.

Partiendo de las especificaciones y escenarios de uso, es muy f√°cil automatizar el desarrollo de pruebas. Sin excusas, buscando los casos l√≠mites y fomentando que el **software evolucione, se corrija y se refactorice**.

Si el proyecto y el equipo lo requieren, puedes aprovechar para pedirle al asistente que aplique patrones de dise√±o o principios de codificaci√≥n que pudieran haberse omitido en una fase anterior. Por ejemplo, hacer el c√≥digo m√°s funcional o m√°s s√≥lido. Lo que quieras. 

Estas mejoras son muy importantes porque influyen en la implementaci√≥n de nuevas funcionalidades, creando un ciclo de retroalimentaci√≥n que mejora la calidad del c√≥digo. Recuerda, tu base de c√≥digo es un contexto para tu agente. **Mejor contexto, mejor trabajo.**

### Mantenimiento

Mantener siempre es algo _a futuro_. No se sabe cu√°ndo, pero ocurrir√°. Y para entonces, todo el conocimiento que se tenga del proyecto se habr√° perdido en la memoria de las personas que lo desarrollaron. As√≠ que mejor que est√© en un soporte m√°s accesible y fiable.

Ya s√© que **todo buen c√≥digo es su mejor documentaci√≥n**. Pero, ¬øqu√© pasa cuando el c√≥digo es tan complejo que no se entiende f√°cilmente? ¬øQu√© pasa cuando el proyecto es realmente grande que no sabes por d√≥nde empezar? ¬øQu√© pasa cuando quien lo va a mantener es un agente cuya especialidad es leer?

Pues que cuanto m√°s contexto escrito disponga mejor ser√°. Y para ello, el Craftsman debe documentar todo lo que haga. Puede empezar con un obligatorio `README`, y un convenio de mensajes de `commit` para la trazabilidad de cambios.

Y esto es solo el principio. Puedes ir hasta el final de la vida del proyecto. Pedir ayuda con el despliegue, la integraci√≥n continua, etc.

Hablando de `git`, el agente puede gestionar el repositorio y adaptarse al _flow_ de trabajo que se haya definido. Crear ramas, desplegar a producci√≥n y revisar c√≥digo son tareas que pueden ser automatizadas.

**Generar documentaci√≥n y mantenerla actualizada** es una tarea que siempre fue considerada como tediosa. Pero ahora es muy f√°cil que pueda ser asignada a un asistente. Diagramas de carpetas f√≠sicas, de componentes l√≥gicos, de clases, etc. Todo ayuda a que el siguiente humano o agente pueda entender mejor el proyecto.

## üåø Conclusi√≥n

En definitiva, el desarrollo de software es un conjunto de actividades intelectuales a las que les ha llegado la hora de ser automatizadas. La clave est√° en **considerar la IA como un miembro m√°s del equipo** asign√°ndole un rol, y no s√≥lo como una herramienta.

No es f√°cil anticipar c√≥mo va a evolucionar la IA y las herramientas que nos ofrecer√°. En el futuro los avances quiz√°s nos lleven a que un √∫nico interlocutor nos baste para completar todo el ciclo de desarrollo. 

Pero, por ahora, es mejor enfocarse en los fundamentos y aceptar los detalles cambiantes. Pensar en roles simples y complementarios me permite que **el Arquitecto, el Constructor y el Artesano** (sean lo que sean en el futuro) trabajen en equipo desde hoy.

### Extra

Estoy creando un [repositorio en GitHub](https://github.com/AIcodeAcademy/AgentBlueprints) llamado `AgentBlueprints` en el que voy a ir a√±adiendo ejemplos, prompts y configuraciones de como implementar estos roles. Desde lo m√°s b√°sico hasta agentes aut√≥nomos. Permanezcan atentos.

